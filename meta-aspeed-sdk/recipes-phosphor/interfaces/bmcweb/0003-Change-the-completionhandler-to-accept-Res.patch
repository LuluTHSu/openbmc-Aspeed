From 79b6aa13b22c9d67e0e6ab7024d8cd51aedc8a16 Mon Sep 17 00:00:00 2001
From: zhanghch05 <zhanghch05@inspur.com>
Date: Wed, 20 Oct 2021 18:43:55 +0800
Subject: [PATCH] Change the completionhandler to accept Res

These modifications are from WIP:Redfish:Query parameters:Only
(https://gerrit.openbmc-project.xyz/c/openbmc/bmcweb/+/47474). And they
will be used in Redfish:Query Parameters:Only.
(https://gerrit.openbmc-project.xyz/c/openbmc/bmcweb/+/38952)
The code changed the completion handle to accept Res to be able to
recall handle with a new Response object.
AsyncResp owns a new res, so there is no need to pass in a res.

Tested:
1.Basic and Token auth both still work.
2.Use scripts/websocket_test.py to test websockets. It is still work
correctly.
python3 websocket_test.py --host 127.0.0.1:2443
This modification is a public part, so you can use any URL to test
this function. The response is the same as before.

Signed-off-by: zhanghaicheng <zhanghch05@inspur.com>
Change-Id: I570e32fb47a9a90fe111fcd1f4054060cd21def3
---

diff --git a/http/http_connection.hpp b/http/http_connection.hpp
index b169309..a0ab1ec 100644
--- a/http/http_connection.hpp
+++ b/http/http_connection.hpp
@@ -332,7 +332,7 @@
             if (thisReq.getHeaderValue(boost::beast::http::field::host).empty())
             {
                 res.result(boost::beast::http::status::bad_request);
-                completeRequest();
+                completeRequest(res);
                 return;
             }
         }
@@ -351,25 +351,27 @@
 
         if (res.completed)
         {
-            completeRequest();
+            completeRequest(res);
             return;
         }
 
         if (!crow::authorization::isOnAllowlist(req->url, req->method()) &&
             thisReq.session == nullptr)
         {
-            BMCWEB_LOG_WARNING << "[AuthMiddleware] authorization failed";
+            BMCWEB_LOG_WARNING << "Authentication failed";
             forward_unauthorized::sendUnauthorized(
                 req->url, req->getHeaderValue("User-Agent"),
                 req->getHeaderValue("Accept"), res);
-            completeRequest();
+            completeRequest(res);
             return;
         }
 
-        res.setCompleteRequestHandler([self(shared_from_this())] {
-            boost::asio::post(self->adaptor.get_executor(),
-                              [self] { self->completeRequest(); });
-        });
+        auto asyncResp = std::make_shared<bmcweb::AsyncResp>();
+        BMCWEB_LOG_DEBUG << "Setting completion handler for connection";
+        asyncResp->res.setCompleteRequestHandler(
+            [self(shared_from_this())](crow::Response& res) {
+                self->completeRequest(res);
+            });
 
         if (thisReq.isUpgrade() &&
             boost::iequals(
@@ -379,10 +381,9 @@
             handler->handleUpgrade(thisReq, res, std::move(adaptor));
             // delete lambda with self shared_ptr
             // to enable connection destruction
-            res.setCompleteRequestHandler(nullptr);
+            asyncResp->res.setCompleteRequestHandler(nullptr);
             return;
         }
-        auto asyncResp = std::make_shared<bmcweb::AsyncResp>(res);
         handler->handle(thisReq, asyncResp);
     }
 
@@ -406,8 +407,7 @@
                                          boost::asio::ip::tcp::socket>>)
         {
             adaptor.next_layer().close();
-#ifdef BMCWEB_ENABLE_MUTUAL_TLS_AUTHENTICATION
-            if (userSession != nullptr)
+            if (sessionIsFromTransport && userSession != nullptr)
             {
                 BMCWEB_LOG_DEBUG
                     << this
@@ -415,7 +415,6 @@
                 persistent_data::SessionStore::getInstance().removeSession(
                     userSession);
             }
-#endif // BMCWEB_ENABLE_MUTUAL_TLS_AUTHENTICATION
         }
         else
         {
@@ -423,12 +422,13 @@
         }
     }
 
-    void completeRequest()
+    void completeRequest(crow::Response& thisRes)
     {
         if (!req)
         {
             return;
         }
+        res = std::move(thisRes);
         BMCWEB_LOG_INFO << "Response: " << this << ' ' << req->url << ' '
                         << res.resultInt() << " keepalive=" << req->keepAlive();
 
@@ -481,7 +481,7 @@
 
         res.keepAlive(req->keepAlive());
 
-        doWrite();
+        doWrite(res);
 
         // delete lambda with self shared_ptr
         // to enable connection destruction
@@ -655,7 +655,7 @@
             });
     }
 
-    void doWrite()
+    void doWrite(crow::Response& thisRes)
     {
         bool loggedIn = req && req->session;
         if (loggedIn)
@@ -667,8 +667,8 @@
             startDeadline(loggedOutAttempts);
         }
         BMCWEB_LOG_DEBUG << this << " doWrite";
-        res.preparePayload();
-        serializer.emplace(*res.stringResponse);
+        thisRes.preparePayload();
+        serializer.emplace(*thisRes.stringResponse);
         boost::beast::http::async_write(
             adaptor, *serializer,
             [this,
diff --git a/http/http_response.hpp b/http/http_response.hpp
index a983d4a..c99b2c3 100644
--- a/http/http_response.hpp
+++ b/http/http_response.hpp
@@ -39,6 +39,8 @@
     Response() : stringResponse(response_type{})
     {}
 
+    Response(Response&& res) = delete;
+
     Response& operator=(const Response& r) = delete;
 
     Response& operator=(Response&& r) noexcept
@@ -113,37 +115,53 @@
     {
         if (completed)
         {
-            BMCWEB_LOG_ERROR << "Response was ended twice";
+            BMCWEB_LOG_ERROR << this << " Response was ended twice";
             return;
         }
         completed = true;
-        BMCWEB_LOG_DEBUG << "calling completion handler";
+        BMCWEB_LOG_DEBUG << this << " calling completion handler";
         if (completeRequestHandler)
         {
-            BMCWEB_LOG_DEBUG << "completion handler was valid";
-            completeRequestHandler();
+            BMCWEB_LOG_DEBUG << this << " completion handler was valid";
+            completeRequestHandler(*this);
         }
     }
 
-    void end(std::string_view bodyPart)
-    {
-        write(bodyPart);
-        end();
-    }
-
     bool isAlive()
     {
         return isAliveHelper && isAliveHelper();
     }
 
-    void setCompleteRequestHandler(std::function<void()> newHandler)
+    void setCompleteRequestHandler(std::function<void(Response&)>&& handler)
     {
-        completeRequestHandler = std::move(newHandler);
+        BMCWEB_LOG_DEBUG << this << " setting completion handler";
+        completeRequestHandler = std::move(handler);
+    }
+
+    std::function<void(Response&)> releaseCompleteRequestHandler()
+    {
+        BMCWEB_LOG_DEBUG << this << " releasing completion handler"
+                         << static_cast<bool>(completeRequestHandler);
+        std::function<void(Response&)> ret = completeRequestHandler;
+        completeRequestHandler = nullptr;
+        return ret;
+    }
+
+    void setIsAliveHelper(std::function<bool()>&& handler)
+    {
+        isAliveHelper = std::move(handler);
+    }
+
+    std::function<bool()> releaseIsAliveHelper()
+    {
+        std::function<bool()> ret = std::move(isAliveHelper);
+        isAliveHelper = nullptr;
+        return ret;
     }
 
   private:
-    bool completed{};
-    std::function<void()> completeRequestHandler;
+    bool completed = false;
+    std::function<void(Response&)> completeRequestHandler;
     std::function<bool()> isAliveHelper;
 
     // In case of a JSON object, set the Content-Type header
diff --git a/http/websocket.hpp b/http/websocket.hpp
index 30a9b9f..324ffd5 100644
--- a/http/websocket.hpp
+++ b/http/websocket.hpp
@@ -193,10 +193,10 @@
     {
         BMCWEB_LOG_DEBUG << "Websocket accepted connection";
 
-        auto asyncResp = std::make_shared<bmcweb::AsyncResp>(
-            res, [this, self(shared_from_this())]() { doRead(); });
+        auto asyncResp = std::make_shared<bmcweb::AsyncResp>();
 
         asyncResp->res.result(boost::beast::http::status::ok);
+        doRead();
 
         if (openHandler)
         {
diff --git a/include/async_resp.hpp b/include/async_resp.hpp
index 8e9584c..7306017 100644
--- a/include/async_resp.hpp
+++ b/include/async_resp.hpp
@@ -15,28 +15,17 @@
 class AsyncResp
 {
   public:
-    AsyncResp(crow::Response& response) : res(response)
-    {}
-
-    AsyncResp(crow::Response& response, std::function<void()>&& function) :
-        res(response), func(std::move(function))
-    {}
+    AsyncResp() = default;
 
     AsyncResp(const AsyncResp&) = delete;
     AsyncResp(AsyncResp&&) = delete;
 
     ~AsyncResp()
     {
-        if (func && res.result() == boost::beast::http::status::ok)
-        {
-            func();
-        }
-
         res.end();
     }
 
-    crow::Response& res;
-    std::function<void()> func;
+    crow::Response res;
 };
 
 } // namespace bmcweb
diff --git a/include/openbmc_dbus_rest.hpp b/include/openbmc_dbus_rest.hpp
index 3188188..0096e86 100644
--- a/include/openbmc_dbus_rest.hpp
+++ b/include/openbmc_dbus_rest.hpp
@@ -2233,9 +2233,7 @@
             [](const crow::Request&,
                const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
                const std::string& connection) {
-                introspectObjects(
-                    connection, "/",
-                    std::make_shared<bmcweb::AsyncResp>(asyncResp->res));
+                introspectObjects(connection, "/", asyncResp);
             });
 
     BMCWEB_ROUTE(app, "/bus/system/<str>/<path>")
diff --git a/redfish-core/lib/sensors.hpp b/redfish-core/lib/sensors.hpp
index f9d806b..5724e86 100644
--- a/redfish-core/lib/sensors.hpp
+++ b/redfish-core/lib/sensors.hpp
@@ -2972,10 +2972,9 @@
         return;
     }
 
-    auto res = std::make_shared<crow::Response>();
-    auto asyncResp = std::make_shared<bmcweb::AsyncResp>(*res);
+    auto asyncResp = std::make_shared<bmcweb::AsyncResp>();
     auto callback =
-        [res, asyncResp, mapCompleteCb{std::move(mapComplete)}](
+        [asyncResp, mapCompleteCb{std::move(mapComplete)}](
             const boost::beast::http::status status,
             const boost::container::flat_map<std::string, std::string>&
                 uriToDbus) { mapCompleteCb(status, uriToDbus); };
